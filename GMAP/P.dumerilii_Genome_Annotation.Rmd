---
title: "P.dumerilii_Genome_Annotation"
author: "mickey-spongebob"
date: "27/01/2020"
output: html_document
bibliography: P.dumerilii_Genome_Refs.bib
env: "## THE 'CONDA' ENVIRONMENT USED FOR THIS PROJECT IS 'platy_genome' ##"
---

```{r setup, include=FALSE}
# Default engine is R however, added python and bash for specific uses throughout project.

## load 'knitr' library
library(knitr)

## ensure the paths of the engines used are specified according to the conda env
knitr::opts_chunk$set(engine.path = list(
  awk = '/Users/mutemi/opt/anaconda3/envs/platy_genome/bin/awk',
  bash = '/Users/mutemi/opt/anaconda3/envs/platy_genome/bin/bash',
  python = '/Users/mutemi/opt/anaconda3/envs/platy_genome/bin/python3',
  sed = '/Users/mutemi/opt/anaconda3/envs/platy_genome/bin/sed',
  grep = '/Users/mutemi/opt/anaconda3/envs/platy_genome/bin/grep',
  perl = '/Users/mutemi/opt/anaconda3/envs/platy_genome/bin/perl5.26.2'
))

```

# Annotation of the _Platynereis dumerilii_ genome
_Platynereis dumerilii_ (herein referred to as _P.dumerilii_) is a species of annelids found along marine coasts ranging from the Azores, Mediterranean, North, Black and Red Seas, English Channel, Atlantic and Pacific, Sea of Japan and Persian Gulf [@fauvel_annelides_1914]. _P.dumerilii_ has been extensively used for several scientific interests ranging from ecological, behavioural/physiological and developmental purposes, with more recent uses in evolution and neurobiology [@fischer_polychaete_2004; @fischer_normal_2010]. Despite the prominent use of this organism in research, a well-annotated genome allowing comparative genomics and genetic manipulation has been challenging [@zantke_genetic_2014; @raible_vertebrate-type_2005]. Toward this goal, long-read sequencing technology aided with dense RNA-sequencing facilitated an assembly and annotation of the _P.dumerilii_ genome. _Chromosome conformation capture with high-throughput sequencing was also performed to better the genome scaffold with the aim of achieving chromosome resolution [@lieberman-aiden_comprehensive_2009]_.

## Long-read sequencing of the _P.dumerilii_ genome
Illumina-based short read sequencing technology has been extensively used to access genome content of many different organisms. 

[PacBio](<https://www.pacb.com>) long-read sequencing technology; with a predicted assembled genome size of ~2 gigabase pair (GBp), which is almost double the previously predicted genome size of ~1 GB [@jha_chromosomes_1995]. 

```{bash}
# Statistics from the CANU and FALCON genome assemblies

# Install the Sanger 'assembly-stats' package
## conda install -c bioconda assembly-stats

# FALCON assembly of the PacBio sequencing data
assembly-stats ~/Data/Pdum_GENOME_TRANSCRIPTOME/Assembly/platy.falcon.fa
#sum = 2054566777, n = 20337, ave = 101026.05, largest = 4102287
#N50 = 160077, n = 3036
#N60 = 125992, n = 4485
#N70 = 96859, n = 6347
#N80 = 71208, n = 8809
#N90 = 43831, n = 12454
#N100 = 3322, n = 20337
#N_count = 0
#Gaps = 0

# CANU assembly of the PacBio sequencing data
assembly-stats ~/Data/Pdum_GENOME_TRANSCRIPTOME/CANU_Assembly/canu_pacbio.contigs.fasta
#stats for canu_pacbio.contigs.fasta
#sum = 1954807323, n = 41851, ave = 46708.74, largest = 2406554
#N50 = 65062, n = 6987
#N60 = 50506, n = 10413
#N70 = 39275, n = 14800
#N80 = 29107, n = 20578
#N90 = 19699, n = 28674
#N100 = 1111, n = 41851
#N_count = 0
#Gaps = 0

# CANU assembly of the Oxford Nanopore sequencing data
assembly-stats ~/Data/Pdum_GENOME_TRANSCRIPTOME/CANU_Assembly/canu_nanopore.contigs.fasta
#stats for canu_nanopore.contigs.fasta
#sum = 707089037, n = 10376, ave = 68146.59, largest = 1166483
#N50 = 92996, n = 2134
#N60 = 75399, n = 2983
#N70 = 61396, n = 4022
#N80 = 49236, n = 5310
#N90 = 36381, n = 6972
#N100 = 1002, n = 10376
#N_count = 0
#Gaps = 0

# BBMap stats.sh can also be used to calculate GC percentage
#stats.sh "~/path/to/genome_assembly/fasta"

#CANU PacBio = 37.74%
#CANU Nanopore = 37.21%
#FALCON PacBio = 37.73%
```

## Evaluating completeness of the _P.dumerilii_ genome assembly 
To assess the completeness of our genome assembly and annotation, we utilised Benchmarking Universal Single-Copy Orthologs [BUSCO v3](<https://busco-archive.ezlab.org/v3/>) [@simao_busco_2015; @waterhouse_busco_2017], a software that searches for single-copy orthologs evident in a genome and/or transcriptome. BUSCO was ran on the draft assembly, the ~1 million transcriptome as well as the transcriptome successfully mapped onto the genome (see analysis below). We initially compared the preliminary assemblies from CANU [@sergey_canu_2017] and [FALCON](<https://pb-falcon.readthedocs.io/en/latest/#>) to decide for which genome assembly to begin annotating. Analyses are presented below:

```{bash}
# View the BUSCO results
cd BUSCO_Summary

## Display the different completeness for the CANU vs. FALCON Genome Assemblies
cd BUSCO_P.dumerilii_Assembly

echo "BUSCO summary for the P.dumerilii CANU assembly:"
echo
###print all lines except the ones beginning with # (metadata)
grep '^[^#]' busco_canu_assembly/short_summary_busco_platy_canu_pacbio.txt

echo
echo "BUSCO summary for the P.dumerilii FALCON assembly:"
echo
grep '^[^#]' busco_falcon_assembly/short_summary_busco_platy_falcon_pacbio.txt

```

Plot to visualise BUSCO results.

```{r, echo=FALSE}
# Plot proportions pie chart to visualise BUSCO results comparing FALCON vs. CANU assemblies
## create a dataframe containing BUSCO scores

#vectors
canu_assembly <- c(631, 101, 55, 191)
falcon_assembly <- c(759, 60, 70, 89)
##rownames
busco_completeness <- c("single", 
                        "duplicate", 
                        "fragmented", 
                        "missing")

#build dataframe
P.dumerilii_assembly <- data.frame("BUSCO" = busco_completeness, 
                                   canu = canu_assembly, 
                                   falcon = falcon_assembly)

##plot pie-chart
#par(mfrow = c(1, 2))    # plot 2 charts side-by-side

## create pie charts
### construct plotting data in percentage format
#### CANU
pct_canu <- round(canu_assembly/sum(canu_assembly)*100)
lbls_canu <- paste(busco_completeness, pct_canu)
lbls_canu <- paste(lbls_canu, "%", sep = "")

pie(canu_assembly, labels = lbls_canu, main = "P.dumerilii CANU Assembly BUSCO summary")

#### FALCON
pct_falcon <- round(falcon_assembly/sum(falcon_assembly)*100)
lbls_falcon <- paste(busco_completeness, pct_falcon)
lbls_falcon <- paste(lbls_falcon, "%", sep = "")

pie(falcon_assembly, labels = lbls_falcon, main = "P.dumerilii FALCON Assembly BUSCO summary")
```

From the summary statistics above, the FALCON assembly contained more single-copy orthologs (orthologs searched were orthologs common to all Metazoa: 819/978[~78%] vs. 732/978[~65%]), with less duplicated sequences (60/978[~6%] vs. 101/978[~10%]). While these data alone are insufficient to judge quality of the P.dumerilii assembly, when we map total RNA-seq data using the STAR (Spliced Transcripts Alignment to a Reference) software [@dobin_star_2013], we find significantly higher 'unique' mapping rates for the FALCON assembled genome (~72%) as opposed to the CANU assembly (~38%; see below).

```{bash}
# Display STAR mapping data for RNA-seq to the CANU vs. FALCON draft genome assemblies

cd STAR_Summary    #change working directory

echo 'CANU Assembly: RNA-seq mapping'
echo
sed -n '5,$p' canu_assembly_STAR_RNAseq.txt    #print all lines except 'metadata'
echo
echo
echo 'FALCON Assembly: RNA-seq mapping'
echo
sed -n '5,$p' falcon_assembly_STAR_RNAseq.txt    #print all lines except 'metadata'

```

From analyses above, all further analyses are based solely on the FALCON assembly version. Summarised below are the assembly attributes of the FALCON _P. dumerilii_ assembly.
```{bash}

#assembly-stats ~/Data/Pdum_GENOME_TRANSCRIPTOME/Assembly/platy.falcon.fa
#stats for /Users/mutemi/Data/Pdum_GENOME_TRANSCRIPTOME/Assembly/platy.falcon.fa
#sum = 2054566777, n = 20337, ave = 101026.05, largest = 4102287
#N50 = 160077, n = 3036
#N60 = 125992, n = 4485
#N70 = 96859, n = 6347
#N80 = 71208, n = 8809
#N90 = 43831, n = 12454
#N100 = 3322, n = 20337
#N_count = 0
#Gaps = 0
```

## _P.dumerilii_ transcriptome-genome alignment based gene modelling and annotation

### A new _de novo_ assembly of the _P.dumerilii_ transcriptome
Massive efforts from the Jekely [@conzelmann_neuropeptide_2013], Schneider [@chou_pdumbase_2018] and Raible and Tessmar-Raible [@schenk_combined_2019] groups, have yielded dense transcriptomes based off of short-read Illumina-based paired-end sequencing technology. We re-built a _de-novo_ transcriptome using RNA-seq data from Conzelmann et al. 2013 due to the sampling from multiple developmental time points [@conzelmann_neuropeptide_2013], as well as additional RNA-seq data generated from multiple adult tissues (i.e. paprapodia, palpae, cirri, stomodeum). [FastQC](<https://www.bioinformatics.babraham.ac.uk/projects/fastqc/>) assessment of the RNA-seq data was also performed prior to assembly. Approximately 1 billion RNA-seq reads were then used to build a transcriptome using the [Trinity software](<https://github.com/trinityrnaseq/trinityrnaseq/wiki>) [@grabherr_full-length_2011; @haas_novo_2013]; with settings of --full_cleanup --KMER_SIZE 25 and --min_kmer_cov 2. From these reads, approximately 1 million 'unique' transcripts were assembled into a _de novo_ transcriptome; with an estimated 396,040 Trinity 'genes' (40.15% GC content).

To test how well the RNA-seq reads are represented in the transcriptome, we aligned the reads to the transcriptome using [Bowtie2](<http://bowtie-bio.sourceforge.net/bowtie2/index.shtml>)[@longmead_fast_2012].

```{bash}
# Go to appropriate working directory
cd P.dumerilii_tXOME

echo "RNA-seq read alignment to transcriptome statistics:"
echo
less align_stats.txt
```

Overall, around 86% of the RNA-seq data used aligned to the transcriptome (see above analysis), with 72.13% of total RNA-seq reads mapped concordantly to the transcriptome; (~59% aligning concordantly more than once and ~13% aligning only once). These numbers are comparable to typical Trinity transcriptome assemblies (see [Trinity Wiki Page](<https://github.com/trinityrnaseq/trinityrnaseq/wiki/RNA-Seq-Read-Representation-by-Trinity-Assembly>)).

```{bash}
# Appropriate working directory
cd P.dumerilii_tXOME

echo "Contig statistics of transcriptome:"
echo
less tXOME_ContigNX_stats.txt
```
In addition, the transcriptome assembly contig N50 was 799bp (i.e. 50% or more of the assembled contigs were at least 799bp in length), with the median contig length at 385bp (average: ~600bp long) and the total transcriptome assembly size at approximately 650 megabase (MB) pairs. As we were sampling from multiple developmental time points and tissue types, we were predominantly interested in building transcripts from RNA-seq reads, irrespective of abundance (i.e. not measuring differential expression analyses). We later filtered the transcriptome further on based on its mapping to the genome (see below).

### Annotation of the _P.dumerilii_ transcriptome
[Trinotate](<https://github.com/Trinotate/Trinotate.github.io/wiki>) [@bryant_tissue-mapped_2017] based annotation of the transcriptome generated a report allowing some detailed look at the transcript diversity (i.e. ribosomal RNAs, protein coding genes), ortholog information and characterisation of transcript features (i.e. signal peptides, transmembrane domains). This file is useful in annotating mapped transcripts and assigning 'gene names' to genome locations/positions. The R-package to read the trinotate file was built by [cstubben](<https://github.com/cstubben/trinotateR>) to read and quickly summarise the trinotate output file. For more information and analyses of the _P.dumerilii_ transcriptome based off the Trinotate output, see the **Platy_Transcriptome_Annotation** R-project.

```{r, echo=FALSE}
# Read in the 'trinotate_annotation_report.xls' file.

## install trinotateR and load file
library(devtools)
library(trinotateR)

## read the .xls file
P.dumerilii_tXOME <- read_trinotate("trinotate_annotation_report.xls")

## save this annotation report as a .csv file for easier manipulation as the .xls format is outdated
write.table(P.dumerilii_tXOME, file = "~/Desktop/RStudio_Projects/Platy_Genome_Annotation/GMAP_GeneModels/trinotate_annotation_report.csv", sep = "&", col.names = NA, qmethod = "escape")

## summary of the trinotate file
### returns the number of unique and total annotations in the table
P.dumerilii_tXOME_summary <- summary_trinotate(P.dumerilii_tXOME)
```

### Mapping statistics of transcripts aligned to draft genome assembly
[GMAP-GSNAP](<http://research-pub.gene.com/gmap/>) [@wu_gmap_2005; @wu_fast_2010], a genomic mapping and alignment program for mRNA and EST sequences was used to generate the best alignment output for each of the ~ 1 million transcripts.

So as to extract basic information regarding tXOME-gNOME mapping statistics, the command lines below were applied to output from GMAP-GSNAP version **2019-09-12**. Note that for the analyses below, the statistics were derived from mapping to the SoftMasked genome i.e. masking was performed using RepeatModeler-open-1.0.11 and RepeatScout-1 [RepeatMasker](<http://www.repeatmasker.org>).

All ~1 million transcripts were extracted (or annotated) from the Trinotate pipeline briefly described above and further mapped to the _P.dumerilii_ soft-masked genome to give a .gff3, .psl and a .txt file. Provided in these files are:
1. Genome coordinates (more specifically the contig positions of the best alignment matches to the genome) 
2. Summary of how many 'paths' or unique mapping events for a given transcript (i.e. if a transcript ONLY maps to one location it will have a 'Path' == 1, if it maps to multiple locations, it will have a 'Path' > 1. If it had no mapping event, 'Path' == 0). _Note_: however that this value applies to a specific transcript ID, meaning that if a transcript maps to two locations it will have 'Path' = 1 and 'Path' = 2.

```{bash}
# Count number of transcripts mapped _at least once_ to the genome.

## total transcripts
echo "Total number of transcripts is:"
grep -c "^Paths" GMAP_Platy_tXOME.txt

## unmapped transcripts
echo "The number of UNMAPPED transcripts is:"
grep -c "^Paths (0):" GMAP_Platy_tXOME.txt

## mapped_ONCE transcripts
echo "The number of MAPPED (once) transcripts is:"
grep -c "^Paths (1):" GMAP_Platy_tXOME.txt

## mapped_MULTIPLE transcripts
  #repeat the same code above except "^Paths (2):" and the result is 213,262
  #i.e. 213,262 transcript IDs have more than one best-match alignment to the draft genome

  #when Paths=3 == 24,127, Paths=4 == 15,051
  #these will be filtered out in the analyses below

## Access all 'genes' from the .gff3 file
### the 'genes' category has sufficient information for downstream analysis
grep "gene" GMAP_Platy_tXOME.gff > GMAP_Platy_tXOME_GENES.txt
```

Approximately ~65.74% transcripts have at least a single best-match alignment to the genome, while around 5.20% did not map at all. The rest (~29.06%) mapped to at-least more than a single location. This number suggests that many of the protein-coding transcripts built from the Trinity-based _de-novo_ transcriptome could potentially be found in the assembled genome. While the transcripts mapped were allowed to contain splice-gaps for intron-exon inferences, the gene boundaries of the transcripts could be relaxed (i.e. extended by ~2 kilobase pairs (Kbp)) to allow for 5' and 3' demarcation. In addition, the multi-mappers make it challenging to model genes from these transcripts as they have more than one 'best-match' alignment according to GMAP-GSNAP. These were filtered out in the attempt to make the gene modelling simpler.

```{r, echo=FALSE}
# Load 'genes' and their contig positions into an R-object for curation

## load libraries necessary for workflow
library(tidyverse)
library(ggplot2)

## load the GMAP_P.dumerilii_prots_GENES.txt file into an R-object
P.dumerilii_GMAP_tXOME <-
  read.table("~/Desktop/RStudio_Projects/Platy_Genome_Annotation/GMAP_GeneModels/GMAP_Platy_tXOME_GENES.txt")

## convert table into tibble for easier manipulation and data-wrangling
P.dumerilii_GMAP_tXOME <- as_tibble(P.dumerilii_GMAP_tXOME)

## rename the P.dumerilii_GMAP_prots headers
names(P.dumerilii_GMAP_tXOME) <- 
  c("contig", "2", "3", "start", "end", "6", "strand", "8", "ID")

## extract the "contig", "strand", "start/end" and "ID"
### extracted based on the column integer index
P.dumerilii_GMAP_tXOME <- P.dumerilii_GMAP_tXOME[-c(2,3,6,8)]
```

From the GMAP results, it is evident that many transcripts map to more than one unique contig (i.e. transcripts that mapped equally well to contigX and contigY). We reasoned the following:
1. The transcript is 'inherently' promiscuous. In essence, such transcripts do not reflect 'true' genes as they can align to several contigs i.e. exist in many different genome locations. 
2. The transcript may represent gene paralogs. In other words, a transcript mapping to contigs X and Y could potentially reflect that in these contig positions, lie closely and evolutionary related genes belonging to the same gene family.
3. The assembly of the genome may have distinguished two (or more) different contigs that should in fact be one and the same i.e. contig_X:pos a-b and contig_Y:pos e-f, could actually be a single contig, or form part of an overlapping portion of a contiguous sequence. 

To first gain a glimpse into the proportion of unique mapping events, all transcripts that mapped to multiple distinct contigs were filtered out. Note that this filtration step allows for events where transcripts mapped to the same contig but in different positions (e.g. contig_X:pos a-b and contig_X:pos k-l). 

In an attempt to create a simpler modelling of gene loci from the transcriptome_genome mapping, we thought removing all unique gene_IDs that map to more than one unique contig could provide a proxy of 'confident' gene models. The code below attempts to do so.

```{r, echo=FALSE}
# Group the transcripts according to their mapping positions

## make a new column containing only the TRINITY_'gene'_ID
P.dumerilii_GMAP_tXOME$LIKELY_GENE <-
  sub("^ID=(TRINITY_DN[0-9]+_c[0-9]_g[0-9]).*",
      "\\1", P.dumerilii_GMAP_tXOME$ID)

## make a separate column containing the TRINITY_'isoform'_ID
P.dumerilii_GMAP_tXOME$LIKELY_ISOFORM <-
  sub("^ID=(TRINITY_DN[0-9]+_c[0-9]_g[0-9]_i[0-9]+).*",
      "\\1", P.dumerilii_GMAP_tXOME$ID)

## filter out contigs that only appear once in the data set
        ## i.e. contigs had a single mapping event/transcript_id
contig_filt_P.dumerilii_GMAP_tXOME <- 
  P.dumerilii_GMAP_tXOME[P.dumerilii_GMAP_tXOME$contig 
                         %in% 
                           names(which(table
                                       (P.dumerilii_GMAP_tXOME$contig) 
                                       >= 2)), ]
         ## a total of 417 contigs were filtered

## filter out isoform_ids from the contig_filt_P.dumerilii_GMAP_tXOME that appear more than once
        ## i.e. isoforms that map to different contigs
isoform_filt_P.dumerilii_GMAP_tXOME <-
  contig_filt_P.dumerilii_GMAP_tXOME[contig_filt_P.dumerilii_GMAP_tXOME$LIKELY_ISOFORM 
                                     %in%
                                       names(which(table
                                                   (contig_filt_P.dumerilii_GMAP_tXOME$LIKELY_ISOFORM)
                                                   < 2)), ]
        ## Check that you have unique LIKELY_ISOFORM values
                ## length(unique(isoform_filt_P.dumerilii_GMAP_tXOME$LIKELY_ISOFORM)) [720,444]
        ## ~45.24% isoform_ids do not appear more than once in different contigs

## group according to LIKELY_GENE column
isoform_filt_P.dumerilii_GMAP_tXOME <- group_by(isoform_filt_P.dumerilii_GMAP_tXOME, LIKELY_GENE, add=TRUE)
        ## provides some way to see redundant gene names due to distinct isoforms exist

## filter out transcript_ids (LIKELY_GENE column) from the isoform_filt_P.dumerilii_GMAP_tXOME that only appear once
        ## i.e. transcripts that do not form a 'gene' cluster
        ## e.g. TRINITY_DNXXXXXX_cX_gX appears only once (given that these transcripts have 'isoforms' at the _iX level)
gene_filt_P.dumerilii_GMAP_tXOME <-
  isoform_filt_P.dumerilii_GMAP_tXOME[isoform_filt_P.dumerilii_GMAP_tXOME$LIKELY_GENE 
                                     %in%
                                       names(which(table
                                                   (isoform_filt_P.dumerilii_GMAP_tXOME$LIKELY_GENE)
                                                   >= 2)), ]
        ## of the 'unique' gene mappers, ~75.13% show 'confident' (at least two isoforms for each gene)
        ## 115,714 unique LIKELY_GENE ids
        ## 14,656 unique contigs 
```

From the analysis above, 417 contigs only had a single mapping event (i.e. a single isoform). These contigs were filtered out because we reasoned that, given the tXOME was assembled from ~1 billion RNA-seq reads (from multiple tissues and developmental stages), the thought that a 'real' gene being only represented by a single transcript isoform was not re-assuring. Given the draft assembly has 20,337 contigs, losing 417 did not seem too great a loss, especially because this was based on single transcript isoform mapping events.

After this, transcript isoforms that mapped to different contigs were filtered out leaving approximately 45.24% of transcripts that map to a unique contig. This number is quite different from the ~65.74% above due to over-representation of 'unique' transcripts. To attempt to overcome this, we asked how many of these 'LIKELY GENES' only have a single isoform. Once more, due to the vast data used, it was felt that for confident gene model assignment, a LIKELY GENE had to have at least 2 isoforms mapping. Upon filtration, this left 14,656 contigs (out of 20,337: ~72.07% draft assembly contigs) and 541,252 transcript IDs (out of 1,592,410: ~34%). While these are stringent approaches to filtration, it was felt that gene model assignment would be made easier, at least for a draft genome.

To inform our future annotation of the gene loci/boundaries of the transcripts that mapped to the genome. We looked to the **trinotate_annotation_report** so as to match the transcripts that mapped to the genome, with their annotations, as best predicted by the Trinotate pipeline.

```{r, echo=FALSE}
# Label the filtered transcripts mapped to genome according to Trinotate file

## extract the Trinotate information of the filtered and genome mapped transcripts
## i.e. gene_filt_P.dumerilii_GMAP_tXOME
anno_filt_P.dumerilii_GMAP_tXOME <- P.dumerilii_tXOME %>%
  filter(transcript_id %in%
           gene_filt_P.dumerilii_GMAP_tXOME$LIKELY_ISOFORM)
```

####PROTEIN-CODING ANNOTATION####
The Trinotate pipeline includes prediction of protein-coding transcripts from the Trinity transcriptome build using [TransDecoder](<https://github.com/TransDecoder/TransDecoder/wiki>) [@haas_novo_2013]. Utilising protein databases with some known orthology information from BLASTp(x), PfAm and SwissProt, the trinotate file allows for rapid annotation of genome-mapped transcripts likely to be protein-coding. 

```{r, echo=FALSE}

## add a simplified_gene_list, Domains and Kingdom column to describe likely orthologous 'proteins' mapped to genome
### use regex to get the names of the orthologous genes in the sprot_Top_BLASTP_hit column
anno_filt_P.dumerilii_GMAP_tXOME$simplified_gene_list <- 
  sub("^([A-Z0-9]+).*", "\\1", anno_filt_P.dumerilii_GMAP_tXOME$sprot_Top_BLASTP_hit)                 
        #^ denotes the first character at the start of the line
        # ([A-Z0-9]+) any alphabet or numeric character
        # .* any character after the bracket

### use regex to get the Domains of the orthologous genes in the sprot_Top_BLASTP_hit column
anno_filt_P.dumerilii_GMAP_tXOME$Domains <- 
  sub("^.*;\\^([A-z]+).*", "\\1", anno_filt_P.dumerilii_GMAP_tXOME$sprot_Top_BLASTP_hit)

### use regex to get the Kingdoms of the orthologous genes in the sprot_Top_BLASTP_hit column
### strictly speaking, this column does not exclusively contain Kingdoms, the nomenclature is very different for certain life groups
anno_filt_P.dumerilii_GMAP_tXOME$Kingdoms <- 
  sub("^.*;\\^([A-z]+); ([A-z]+).*", "\\2", anno_filt_P.dumerilii_GMAP_tXOME$sprot_Top_BLASTP_hit)

### count the number of unique orthologous (at least at the protein level) genes in tXOME-gNOME mapping
No._uniq_orth_prots <- length(unique(anno_filt_P.dumerilii_GMAP_tXOME$simplified_gene_list))
        # 12,603 out of 14,998 ~84.03% of possible orthologs identified in tXOME (see **P.dumerilii_Trinotate.Rmd**) 
        # 12,603 out of 115,427 ~10.92% of unique transcripts mapped to genome are protein-coding with known orthologs

### proteins in mapped tXOME
prots_P.dumerilii_GMAP_tXOME <- 
  dplyr::filter(anno_filt_P.dumerilii_GMAP_tXOME, prot_id != 'NA')

#### count how many 'unique' genes defined as proteins by Trinotate mapped to the genome
No._uniq_prots <- length(unique(prots_P.dumerilii_GMAP_tXOME$gene_id))
        # 48,698 out of 115,427 [~42.19%] of transcripts mapped to genome have protein-coding potential
        # 12,603 out of 48,698 [~25.88%] have known orthologs 
```

To briefly summarise the analysis above:of the total transcripts confidently mapped to the genome, ~42% (48,698 out of 115,427) were predicted to have protein-coding potential from Trinotate. Around 25% of these had known orthologs (i.e. 12,603 out of 48,698) spanning Archaea, Bacteria, Eukaryota and Viruses. Thus, the total number of orthologous 'proteins' mapped to the genome sits at ~11% (12,603 out of 115,427). When analysing only the transcriptome file using Trinotate (i.e. not including the mapping of these transcripts to the genome; see **P.dumerilii_Trinotate.Rmd** file), 14,998 unique orthologs were found. Suggesting that many of these transcripts are well represented in the mapping to the genome (12,603 out of 14,998: ~84.03%).

In addition to above analysis, we sought to test the annotations of the proteins predicted using the Trinotate pipeleine using a different measure. Toward this aim, we sought to build a [Phylome](<phylomedb.org>) for the predicted proteins, which attempts to reconstruct the evolutionary relationships of all proteins in a dataset, thus grouping sequences according to their orthology information [@huerta-cepas_human_2007]. From this initial grouping, one could compare orthology assignment in the Trinotate pipeline, as well as understand relationships between unknown protein sequences within species' of interest i.e. compare orthology information at various scales including Spiralia (or Lophotrochozoa), Protostomes, Bilateria and Metazoa. 

The proteome analysed here was built using TransDecoder [@haas_novo_2013], with a minimum open-reading frame (ORF) length at 100 amino acids (AA).  

```{bash}
# enter correct working directory
cd P.dumerilii_proteome

# extract header information from the *TransDecoder.pep file
grep "^>" TransDecoder_kmer2tXOME.pep > P.dumerilii_proteome_headers.txt

```
```{r, echo=FALSE}
# Read the 'P.dumerilii_proteome_headers.txt' file into R as an R object
## for ease in manipulation
P.dumerilii_proteome_sequences <-
  read.table("~/Desktop/RStudio_Projects/Platy_Genome_Annotation/GMAP_GeneModels/P.dumerilii_proteome/P.dumerilii_proteome_headers.txt")

#access the lengths of each transcript_id 
P.dumerilii_proteome_sequences$length <- 
  sub("len:([0-9]+)", "\\1", P.dumerilii_proteome_sequences$V5)

#make new column with transcript_id
P.dumerilii_proteome_sequences$transcript_id <- 
  sub("^>([A-z0-9]+).p.*", "\\1", P.dumerilii_proteome_sequences$V1)

#make new column with gene_id
P.dumerilii_proteome_sequences$gene_id <- 
  sub("^([A-z0-9]+.)~~.*", "\\1", P.dumerilii_proteome_sequences$V2)

#group and select longest length for each given gene_id
gene_id_filt_proteome <-
  P.dumerilii_proteome_sequences %>% group_by(gene_id) %>% summarise(length = max(length))

#filter P.dumerilii_proteome_sequences 
filt_P.dumerilii_proteome_sequences <-
  right_join(P.dumerilii_proteome_sequences, gene_id_filt_proteome, by = c("gene_id", "length"))

filt_P.dumerilii_proteome_sequences <-
  filt_P.dumerilii_proteome_sequences %>% distinct(gene_id, .keep_all = TRUE)
```
We then accessed the protein coding transcript ids (see P.dumerilii_prots_All) and found that at the 'gene_id' level, there are 83,838 'unique' (at least by 'gene_id') predicted proteins from the transcriptome. From this list, we took the longest predicted protein sequence yielding a list of 74,029 proteins at the unique 'gene_id' level. These sequences were further used to filter out the ~300,000 _P.dumerilii_ protein-rich proteome file that was later submitted for phylome analyses [@huerta-cepas_human_2007], i.e. construct an evolutionary and orthology-based protein sequence annotation. In addition, we separately annotated this proteome list using InterProScanv5 [@jones_interproscan_2014; @mitchell_interpro_2018] for known domains.   


#### _Mapping P.dumerilii PacBio Isoseq transcripts onto the draft assembly_ ####
From the Illumina based RNA-seq transcriptome above (1_million_tXOME), it was evident that there are several isoforms per given 'gene_id'. Furthermore, while these transcripts often occupy gene loci that are overlapping, it is difficult to model gene structures from relatively fragmented transcripts. PacBio long-read transcriptome sequencing data (performed by Mette Handberg-Thorsager, Bruno Vellutini, Sylke Winkler and Pavel Tomancak) was then mapped to the genome using GMAP-GSNAP, in the attempt to reconstruct full length transcripts. Below are the analyses of the mapping:

```{bash}
## Performed similar analyses to those below
## Similar code to ####_Mapping known P.dumerilii coding sequences (CDS)...####

#*Count mapping events*#
## total IsoSeq tXs
echo "Total number of IsoSeq tXs is:"
grep -c "^Paths" P.dumerilii_long-read_PacBio_tXOME/GMAP_PacBio/GMAP_Platy_IsoSeq_tXOME.txt

## unmapped IsoSeq tXs
echo "The number of UNMAPPED IsoSeq tXs is:"
grep -c "^Paths (0):" P.dumerilii_long-read_PacBio_tXOME/GMAP_PacBio/GMAP_Platy_IsoSeq_tXOME.txt

## mapped_ONCE IsoSeq tXs
echo "The number of MAPPED (at least once) IsoSeq tXs is:"
grep -c "^Paths (1):" P.dumerilii_long-read_PacBio_tXOME/GMAP_PacBio/GMAP_Platy_IsoSeq_tXOME.txt

## mapped_TWICE IsoSeq tXs
echo "The number of MAPPED (at least twice) IsoSeq tXs is:"
grep -c "^Paths (2):" P.dumerilii_long-read_PacBio_tXOME/GMAP_PacBio/GMAP_Platy_IsoSeq_tXOME.txt

## mapped_THRICE IsoSeq tXs
echo "The number of MAPPED (at least thrice) IsoSeq tXs is:"
grep -c "^Paths (3):" P.dumerilii_long-read_PacBio_tXOME/GMAP_PacBio/GMAP_Platy_IsoSeq_tXOME.txt
```

From the mapping statistics above, around 99.5% of the IsoSeq transcripts mapped to the soft-masked _P.dumerilii_ FALCON assembly genome. Around 81% transcripts had a single path i.e. mapped at least once, with ~17.5% mapping at least twice and a small percentage (~0.4%) mapping at least three times. 

```{bash}
# Access coverage data from the IsoSeq_tXs-to-genome mapping 

### Make sure to work in the directory where the files are located
cd P.dumerilii_long-read_PacBio_tXOME/GMAP_PacBio/

## collect the IsoSeq tXs .gff info so as to evaluate coverage statistics
grep "mRNA" GMAP_Platy_IsoSeq_tXOME.gff > IsoSeq_tX_list.txt

## remove the first line from IsoSeq_tX_list.txt (contains the 'metadata' of mapping)
sed -i '' -e '1d' IsoSeq_tX_list.txt 
```

The 'IsoSeq_tX_list.txt' file was then read into R as 'delimited' file so that one could easily manipulate and explore the data.

```{r, echo=FALSE}

## read in the IsoSeq_tX_list.txt file as a delimited file
P.dumerilii_IsoSeq_tXs <- 
  read.delim("P.dumerilii_long-read_PacBio_tXOME/GMAP_PacBio/IsoSeq_tX_list.txt", 
             header = FALSE, sep = "\t")

## label and organize the P.dumerilii_IsoSeq_tXs table
### rename the headers
names(P.dumerilii_IsoSeq_tXs) <- 
  c("contig", "2", "3", "start", "end", "6", "strand", "8", "ID")

### extract the "contig", "strand", "start/end" and "ID"
### extracted based on the column integer index
P.dumerilii_IsoSeq_tXs <- P.dumerilii_IsoSeq_tXs[-c(2,3,6,8)]

## use regex to acquire the mRNA name
P.dumerilii_IsoSeq_tXs$IsoSeqtX_ID <-
  sub("^.*Name=([A-z0-9]*.[0-9]).*", "\\1", P.dumerilii_IsoSeq_tXs$ID)

## use regex to extract 'coverage' values
P.dumerilii_IsoSeq_tXs$coverage <- 
  sub("^.*coverage=([0-9]+.[0-9]).*", "\\1", P.dumerilii_IsoSeq_tXs$ID)

## use regex to extract 'identity' values
P.dumerilii_IsoSeq_tXs$identity <-
  sub("^.*identity=([0-9]+.[0-9]).*", "\\1", P.dumerilii_IsoSeq_tXs$ID)
```

Visualising the data of coverage and identity distributions:

```{r, echo=FALSE}
## convert to tibble, tidyverse data object for ease in manipulation
P.dumerilii_IsoSeq_tXs <- as_tibble(P.dumerilii_IsoSeq_tXs)

## basic plotting:
par(mfrow=c(2,3))    # set plotting area into a 2-by-3 array

### coverage
#_Base-plot_
plot(P.dumerilii_IsoSeq_tXs$coverage,
     ylab = "% coverage", col = 'deepskyblue')

#_Histogram_
hist(as.numeric(P.dumerilii_IsoSeq_tXs$coverage), 
     breaks = seq(0, 100, by=10),
     xlab = "% coverage",
     ylim = c(0, 200000),
     col = 'deepskyblue',
     main = "")

#_box-plot_
boxplot(as.numeric(P.dumerilii_IsoSeq_tXs$coverage),
        ylab = "% coverage", col = 'deepskyblue')

### identity
#_Base-plot_
plot(P.dumerilii_IsoSeq_tXs$identity,
     ylab = "% identity", col = 'darkorange',
     ylim = c(0, 100))

#_Histogram_
hist(as.numeric(P.dumerilii_IsoSeq_tXs$identity), 
     breaks = seq(0, 100, by=10),
     xlab = "% identity",
     ylim = c(0, 200000),
     col = 'darkorange',
     main = "")

#_box-plot_
boxplot(as.numeric(P.dumerilii_IsoSeq_tXs$identity),
        ylab = "% identity", col = 'darkorange',
        ylim = c(0, 100))
```


#### _Mapping known P.dumerilii coding sequences (CDS) from GenBank onto draft assembly_ ####
As a way to double-check the Trinotate annotation pipeline, as well as explore how well known sequences are represented in the draft assembly, we mapped previously annotated (and/or) well-known mRNA and DNA sequences using GMAP-GSNAP (see above). 359 mRNA sequences with complete coding sequences (CDS), a previously sequenced histone gene cluster for core histones H2A, H2B, H3 and H4 (Accession No. X53330.1) [@sellos_organization_1990] were extracted from GenBank/Nucleotide and mapped to the soft-masked genome.
Below, a summary of the mapping:

##### _P.dumerilii 359 mRNA sequences_ #####
```{bash}
# Count number of mapped CDS to the soft-masked genome 
## GMAP results are in the "P.dumerilii_complete-mRNA" folder

## total CDS
echo "Total number of CDS is:"
grep -c "^Paths" P.dumerilii_complete-mRNA/GMAP_Platy_complete-mRNA.txt

## unmapped CDS
echo "The number of UNMAPPED CDS is:"
grep -c "^Paths (0):" P.dumerilii_complete-mRNA/GMAP_Platy_complete-mRNA.txt

## mapped_ONCE CDS
echo "The number of MAPPED (once) CDS is:"
grep -c "^Paths (1):" P.dumerilii_complete-mRNA/GMAP_Platy_complete-mRNA.txt

## mapped_TWICE CDS
echo "The number of MAPPED (twice) CDS is:"
grep -c "^Paths (2):" P.dumerilii_complete-mRNA/GMAP_Platy_complete-mRNA.txt
```

Given the mapping statistics above, all but two transcripts are mapped to the draft assembly (GenBank IDs: AY534532.2 ( _Nematostella vectensis_ secreted signalling factor wnt-A mRNA) and KU206575.1 ( _Capitella teleta_ neurotrophin 2 mRNA)). While many appear to have mapped once, there remains a significant proportion that mapped more than once [**Note**: No transcripts mapped more than twice]. From manual inspection of the .gff file, we noticed that many of the transcripts that showed two mapping events, had distinct coverage values i.e. the portion of the transcript aligned to the genome. From this inspection, we explored the distribution of coverage values for the different transcripts so as to get an estimate of reasonable filters or cut-offs. Below is the analysis:

```{bash}
# Access coverage data from the 359 mRNA(s)-to-genome mapping 

### Make sure to work in the directory where the files are located
cd P.dumerilii_complete-mRNA/

## collect the mRNA .gff info so as to evaluate coverage statistics
grep "mRNA" GMAP_Platy_complete-mRNA.gff > mRNA_list.txt

## remove the first line from mRNA_list.txt (contains the 'metadata' of mapping)
sed -i '' -e '1d' mRNA_list.txt 
```

The 'mRNA_list.txt' file was then read into R as 'delimited' file so that one could easily manipulate and explore the data.

```{r, echo=FALSE}

## read in the mRNA_list.txt file as a delimited file
P.dumerilii_359mRNA_CDS <- 
  read.delim("P.dumerilii_complete-mRNA/mRNA_list.txt", header = FALSE, sep = "\t")

## label and organize the P.dumerilii_359mRNA_CDS table
### rename the P.dumerilii_359mRNA_CDS headers
names(P.dumerilii_359mRNA_CDS) <- 
  c("contig", "2", "3", "start", "end", "6", "strand", "8", "ID")

### extract the "contig", "strand", "start/end" and "ID"
### extracted based on the column integer index
P.dumerilii_359mRNA_CDS <- P.dumerilii_359mRNA_CDS[-c(2,3,6,8)]

## use regex to acquire the mRNA name
P.dumerilii_359mRNA_CDS$mRNA_ID <-
  sub("^.*Name=([A-z0-9]*.[0-9]).*", "\\1", P.dumerilii_359mRNA_CDS$ID)

## use regex to extract 'coverage' values
P.dumerilii_359mRNA_CDS$coverage <- 
  sub("^.*coverage=([0-9]+.[0-9]).*", "\\1", P.dumerilii_359mRNA_CDS$ID)

## use regex to extract 'identity' values
P.dumerilii_359mRNA_CDS$identity <-
  sub("^.*identity=([0-9]+.[0-9]).*", "\\1", P.dumerilii_359mRNA_CDS$ID)
```

Visualising the data of coverage and identity distributions:

```{r, echo=FALSE}
## convert to tibble, tidyverse data object for ease in manipulation
P.dumerilii_359mRNA_CDS <- as_tibble(P.dumerilii_359mRNA_CDS)

## basic plotting:
par(mfrow=c(2,3))    # set plotting area into a 2-by-3 array

### coverage
#_Base-plot_
plot(P.dumerilii_359mRNA_CDS$coverage,
     ylab = "% coverage", col = 'deepskyblue')

#_Histogram_
hist(as.numeric(P.dumerilii_359mRNA_CDS$coverage), 
     breaks = seq(0, 100, by=10),
     xlab = "% coverage",
     ylim = c(0, 400),
     col = 'deepskyblue',
     main = "")

#_box-plot_
boxplot(as.numeric(P.dumerilii_359mRNA_CDS$coverage),
        ylab = "% coverage", col = 'deepskyblue')

### identity
#_Base-plot_
plot(P.dumerilii_359mRNA_CDS$identity,
     ylab = "% identity", col = 'darkorange',
     ylim = c(0, 100))

#_Histogram_
hist(as.numeric(P.dumerilii_359mRNA_CDS$identity), 
     breaks = seq(0, 100, by=10),
     xlab = "% identity",
     ylim = c(0, 500),
     col = 'darkorange',
     main = "")

#_box-plot_
boxplot(as.numeric(P.dumerilii_359mRNA_CDS$identity),
        ylab = "% identity", col = 'darkorange',
        ylim = c(0, 100))
```
From the data displayed above, many sequences appear to show high identity matches (i.e. lowest at ~80%) with more variability/spread in the coverage numbers. An arbitrary cut-off of 40% coverage was then used so as to filter out mapping events where less than 40% of the sequence aligned to the genome. The cut-off sits between the 1.5 and 2 standard deviations (SDs) less than the mean ( _Note_: the SD is ~26.3).

```{bash}
# Filter out transcripts that have less than 40% coverage

## make sure to work in directory that contains the files
cd P.dumerilii_complete-mRNA

awk -Fcoverage= '$2+0>=40' mRNA_list.txt > mRNA_filt_list.txt
```

```{r, echo=FALSE}
# Filter out P.dumerilii_359mRNA_CDS

## set column 'coverage' values as numeric
P.dumerilii_359mRNA_CDS$coverage <- as.numeric(P.dumerilii_359mRNA_CDS$coverage)

## filter based off 40% cut-off
filt_P.dumerilii_359mRNA_CDS <- dplyr::filter(P.dumerilii_359mRNA_CDS,
                                              coverage >= 40.00)

## count number of unique mRNA
#print ("The number of complete unique mRNAs mapped to genome is")
#length(unique(P.dumerilii_359mRNA_CDS$mRNA_ID))    #357

#print ("The number of complete unique mRNAs filtered for greater than 40% coverage is:")
#length(unique(filt_P.dumerilii_359mRNA_CDS$mRNA_ID))    #356

## identify transcripts with double mapping
unfilt_doublemap_359mRNA <- P.dumerilii_359mRNA_CDS$mRNA_ID[P.dumerilii_359mRNA_CDS$mRNA_ID 
                                     %in% 
                                       names(which(table
                                                   (P.dumerilii_359mRNA_CDS$mRNA_ID) == 2))]

filt_doublemap_359mRNA <- filt_P.dumerilii_359mRNA_CDS$mRNA_ID[filt_P.dumerilii_359mRNA_CDS$mRNA_ID 
                                     %in% 
                                       names(which(table
                                                   (filt_P.dumerilii_359mRNA_CDS$mRNA_ID) == 2))]

## create lists of both data sets for easy description
unfilt_doublemap_359mRNA_list <- as.list(unfilt_doublemap_359mRNA)
filt_doublemap_359mRNA_list <- as.list(filt_doublemap_359mRNA)

## count nnumber of unique double mapping 
#length(unique(unfilt_doublemap_359mRNA_list))
#length(unique(filt_doublemap_359mRNA_list))

## Plot pie-charts
#dev.new(width = 50, height = 8)
#par(mfrow=c(2,1))    # set plotting area into a 1-by-2 array

### un-filtered mRNA mapping events
unfilt_359_vect <- c(length(unique(unfilt_doublemap_359mRNA_list)),
                         (length(unique(P.dumerilii_359mRNA_CDS$mRNA_ID)) - length(unique(unfilt_doublemap_359mRNA_list))))

pct_unfilt <- round(unfilt_359_vect/sum(unfilt_359_vect)*100)
lbls_unfilt <- paste(c("Double-mappers", "Single-mappers"), pct_unfilt)
# add % to labels
lbls_unfilt <- paste(lbls_unfilt, "%", sep = "")

pie(unfilt_359_vect, labels = lbls_unfilt, main = "Unfiltered mapping proportions")

### filtered mRNA mapping events
filt_359_vect <- c(length(unique(filt_doublemap_359mRNA_list)),
                         (length(unique(P.dumerilii_359mRNA_CDS$mRNA_ID)) - length(unique(filt_doublemap_359mRNA_list))))

pct_filt <- round(filt_359_vect/sum(filt_359_vect)*100)
lbls_filt <- paste(c("Double-mappers", "Single-mappers"), pct_filt)
# add % to labels
lbls_filt <- paste(lbls_filt, "%", sep = "")

pie(filt_359_vect, labels = lbls_filt, main = "Filtered mapping proportions")
```

From the analysis above, majority of the previously annotated transcripts map confidently to the genome i.e. only a single mapping event with high coverage and identity percentages. Around 6% showed double mapping with high coverage for both mapping events suggesting that either these portions of the genome are not easily resolvable (i.e. 'high' polymorphism) or, that these transcripts perhaps contain paralogs that have yet to be annotated. We then manually explored the 23 transcripts that mapped confidently to two unique contigs so as to get an idea of the types of genes that show these double-mapping events. Eight of these transcripts were previously annotated as orphan G-protein coupled receptors (GPCRs-10, 19, 31, 34, 36, 37, 51 and 58). The transcription factors Islet, Elav, Twist and AP2 also showed double mapping events. Three neuropeptide precurors (Insulin related peptide 2, CLCCY and WLD) as well as the FL-amide receptor were among other genes that mapped confidently to two unique contigs. Lastly, Pygopus (a Wnt signalling component), Delta (the transmembrane Notch receptor protein), Myosin-2, Myohemerythrin, Fatty-acid binding protein, Aldehyde dehydrogenase 1 and Carboxylesterase 2 were also  included in this list (see table: _double_mapping_mRNA.txt_). Whether these double mapping events are due to paralogs or erroneous assembly in these specific contigs, remains to be tested. The latter possibility is favored as the identity percentages of the sequence aligned to the different contigs are equally high (~ > 90%) for many of these transcripts. As mentioned above, in order to resolve this question, we hope to perform Hi-C experiments so as to scaffold the contigs and aim toward a chromosome resolution of the _P.dumerilii_ genome.

In addition, to complement earlier analyses we examined the gene features of the 359 annotated transcripts to the long-read PacBio transcripts, as well as the ~1 million transcript transcriptomes mapped to the genome. Below are the analyese:

```{bash}
## Analysis of the GFF files from the complete-mRNA vs. long-read PacBio tXOME
# Downloaded the AGAT: Another Gff Analysis Toolkit
# https://github.com/NBISweden/AGAT/blob/master/README.md#install

## conda activate platy_genome
## conda install -c bioconda agat

### Extract features from the ~1 million tXOME
#agat_sp_statistics.pl --gff GMAP_Platy_tXOME.gff -o P.dumerilii_tXOME_features.txt

### Extract features from mRNA
#agat_sp_statistics.pl --gff GMAP_Platy_complete-mRNA.gff -o P.dumerilii_359mRNA_features.txt

### Extract features from PacBio long-read tXOME
#agat_sp_statistics.pl --gff GMAP_Platy_IsoSeq_tXOME.gff -o P.dumerilii_IsoSeq_tXOME_features.txt

# List the 'mean' statistics from these files
###make sure to work in the directory of the files
#~1 million tXOME
grep "^mean" P.dumerilii_tXOME_features.txt > mean_features_1million_tXOMEmapping.txt

#IsoSeq tXOME
grep "^mean" P.dumerilii_IsoSeq_tXOME/GMAP_PacBio/P.dumerilii_IsoSeq_tXOME_features.txt > mean_features_IsoSeq_tXOMEmapping.txt

#mRNA annotated
grep "^mean" P.dumerilii_complete-mRNA/P.dumerilii_359mRNA_features.txt > mean_features_359mRNAmapping.txt
```
```{r, echo=FALSE}
# Read the mean_features tables into R for data visualisation
## 
mean_features_list = list.files(pattern="mean_features")
mean_features_files = lapply(mean_features_list, read.delim)

##join these tables based on rows
```

##### _P.dumerilii histone cluster_ #####
We also mapped a previously sequenced histone gene cluster for core histones H2A, H2B, H3 and H4 (Accession No. X53330.1) to the draft assembly. Below are the analyses:

```{bash}
# Basic summary of mapping of the histone cluster sequence

## ensure the working directory is correct
cd P.dumerilii_histones/

## view the GMAP output
cat GMAP_Platy_core-hist_gNOME.txt
```

From the mapping summary, the histone cluster mapped to a single unique contig. Nonetheless, the sequence alignments show two distinct "Paths" for the histone cluster sequence. Curiously, the sequences still map to the same contig, and around the same positions i.e. Contig 017725F between pos. 4,152..7,999 and pos. 8,576..5,137. The difference between these two mapping events are the strandedness, coverages and amino-acid changes. Given the histone cluster is thought to have H4 and H2A oriented in the opposite strand as H3 and H2B, we reasoned that the mapping that reflects cDNA indeterminate (**017725F: 4,152..7,999, + strand**) as the correct strandedness and alignment. In addition, this same sequence alignment shows the highest coverage and identity values ( _coverage_:57.3% vs 39.0% and _identity_:98.4% vs 96.7%). We then chose to use the **017725F: 4,152..7,999, + strand** as the mapping co-ordinates for this histone cluster. 

####RIBOSOMAL-RNA ANNOTATION####

Trinotate utilised [RNAMMER1.2](<http://www.cbs.dtu.dk/services/RNAmmer/>) [@lagesen_rnammer_2007] to predict 5s/8s, 16s/18s and 23s/28s ribosomal RNA (rRNA) sequences. From the P.dumerilii_tXOME_summary Trinotate file, the transcriptome is poised to have 113 total rRNA sequences. Below, we examine how many of these were represented in the transcriptome to genome mapping.

```{r, echo=FALSE}

## count total unique number of genome-mapped transcripts with RNAMMER assignment
No._rRNA_types_all <- length(unique(anno_filt_P.dumerilii_GMAP_tXOME$RNAMMER))
        # this yielded eight rRNA sequences (excluding 'NA' row values)
```

From this initial survey of how many rRNAs existed in the genome-mapped transcript file, eights rRNA sequences were identified: five 18s_rRNA and three 28s_rRNA. This analysis did not find 8s_rRNA, which was readily identified in the transcriptome (see **P.dumerilii_Trinotate.Rmd** file). Note that 8s_rRNA annotation is incorrect. According to the paper [@lagesen_rnammer_2007], there may have been typos, or it could have been a way to distinguish datasets. Nevertheless, our current understanding/interpretation suggests that 8s_rRNA annotation technically stands for 5s_rRNA (**NOT** 5.8s_rRNA!!); also see [link](<https://www.biostars.org/p/257235/>).  

These low numbers of identified rRNAs led us to manually inspect the pre-filtered transcriptome-genome file (contig_filt_P.dumerilii_GMAP_tXOME) for RNAMMER predicted transcript IDs from the initial Trinotate file. 

##filtered 5/8s_rRNA such that if sequence was greater than 1kb it was not considered as a rRNA mapping event

In addition, we used previously annotated ribosomal DNA sequences [@hui_duplication_2007] to better describe the presence of these sequences in the draft assembly. These sequences were extracted from GenBank (Accession No. EF117899.1 - EF117908.1). The rDNA clusters are thought to reside on nucleolar organization regions (NORs) on chromosomes 5 and 6 [@hui_duplication_2007]. Furthermore, PCR sequence analysis suggested that the 18S and 28S partial seqeunces had no polymorphisms whereas the interspacer regions (ITS) 1 and 2, including the 5.8S regions showed polymorphic rates of 2.34, 2.71 and 0.63% respectively [@hui_duplication_2007]. We mapped the concatenated sequence of these regions (GenBank Accession No.EF117899.1 - EF117908.1) using GMAP-GSNAP (see above) and the results are shown below:

```{bash}

```

####MITOCHONDRIAL DNA ANNOTATION####

The genomic DNA extraction did not include a step to rid off the mitochondrial genome. Previously, the _P.dumerilii_ mitochondrial genome revealed a total size of 15,619 nt (~15.6kb) with an A+T content of 64.1% [@boore_complete_2001]. _P.dumerilii_ mitochondrial DNA (mtDNA) contained 37 genes (we only observed 35) 22 of which are tRNAs and 13 are protein-coding. There also consists a large non-coding region approximately 1090nt (~1.1kb) [@boore_complete_2001]. In order to annotate mtDNA in the total genomic DNA assembly, we mapped these different sequences to the assembled genome (soft-masked) using GMAP-GSNAP (see above). Sequences were accessed from NCBI-GenBank (Accession No. AF178678.1) and the individual fasta files were obtained using a .gb-to-.fa converter provided by [The Rocap Lab](<https://rocaplab.ocean.washington.edu/tools/genbank_to_fasta/>).The resulting annotation is summarised below:

```{bash}
# Basic summary of mapping of the mitochondrial DNA sequences

## ensure the working directory is correct
cd P.dumerilii_mito/

## mitochondrial coding-sequences
## view the GMAP output
#less mtCDS/GMAP_Platy_mtCDS.txt  

# count number of "Paths" i.e. unique mapping events
echo "Total number of uniquely mapped mitochondrial CDS is:"
grep -c "^Paths" mtCDS/GMAP_Platy_mtCDS.txt

## mapped_ONCE mtCDS
echo "The number of MAPPED (once) mitochondrial CDS is:"
grep -c "^Paths (1):" mtCDS/GMAP_Platy_mtCDS.txt

## mitochondrial non-coding region sequence
## view the GMAP output
echo 
echo "The non-coding mitochondrial DNA mapping to the draft assembly is:"
less mtncREG/GMAP_Platy_mtncREG.txt

## mitochondrial transfer-RNAs
## view the GMAP output
#less mttRNA/GMAP_Platy_mttRNA.txt

# count the number of "Paths" i.e. unique mapping events
echo
echo "Total number of uniquely mapped mitochondrial tRNAs is:"
grep -c "^Paths" mttRNA/GMAP_Platy_mttRNA.txt

## mapped_ONCE mtCDS
echo "The number of MAPPED (once) mitochondrial tRNAs is:"
grep -c "^Paths (1):" mttRNA/GMAP_Platy_mttRNA.txt
```

From the mapping results, all mitochondrial coding sequences were mapped to the draft assembly, and only once. Suggesting high fidelity mapping of mtCDS to the genome. In addition, all CDS mapped to a single contig **016072F** (see _GMAP_Platy_mtCDS.txt_). The non-coding mitochondrial sequence previously annotated is also contained within the **016072F** contig (see _GMAP_Platy_mtncREG.txt_), and also has a single mapping event, once more suggesting high-fidelity mapping, with the 22 tRNAs also showing single-unique mapping events on the same contig (see _GMAP_Platy_mttRNA.txt_). Thus, we reason that the mitochondrial genome is well captured from the genome assembly.

####Small RNA ANNOTATTION####

##### _miRNA_ ######
Small RNA sequencing analysis to annotate _P. dumerilii_ miRNAs. Manual annotation for the predicted miRNAs from _P. dumerilii_ were compared against the annotated _Capitella teleta_ miRNA database.

```{r, echo=FALSE}
# Load the miRDeep2 analysis of small RNA-seq read mapping to the genome
## Skip the first 25 lines which describe the score values; this info can be found in the associated .html file
miRNA_Genome_mapping <- 
  read.csv("~/Desktop/RStudio_Projects/Platy_Genome_Annotation/miRDeep2_genome/result_10_03_2020_t_16_14_01.csv", sep = "\t", header = TRUE, skip = 26)
```

From the algorithm, a miRDeep2.score greater than 0 suggests an estimated signal-to-noise ration above 6.6. From the .csv file loaded, miRNA predictions were based off miRDeep2 scores greater than 0. Nevertheless, the this score ranges between 0 to 6,735,728; making it difficult to ascertain biologically plausible miRNA sequences from the 864 mapping events. Below, we evaluate and plot distribution of the miRDeep2.score:

```{r, echo=FALSE}
# Plot a density plot of miRDeep2.score values
## convert to tibble, tidyverse data object for ease in manipulation
miRNA_Genome_mapping <- as_tibble(miRNA_Genome_mapping)

## basic plotting:
par(mfrow=c(1,3))    # set plotting area into a 1-by-3 array

###
#_Base-plot_
plot(miRNA_Genome_mapping$miRDeep2.score,
     ylab = "miRDeep2_score", col = 'orchid2', xlab = "")

#_Log2-plot
plot(log2(miRNA_Genome_mapping$miRDeep2.score),
     ylab = "log2_miRDeep2_score", col = 'skyblue1', xlab = "")

#_Log10-plot
plot(log10(miRNA_Genome_mapping$miRDeep2.score),
     ylab = "log10_miRDeep2_score", col = 'gold2', xlab = "")
```
As the data was very skewed, we log-transformed the data to better display the relative differences between the data points. We noted that there appeared to be an 'inflection' - change of curve propensity - (~500 on the x-axis), whereby the miRDeep2_score changes distinctly. We sought to calculate this point in hopes of setting some threshold or cut-off for miRDeep2_score:

```{r, echo=FALSE}
# Calculate inflection point so as to set a cut-off for downstream analyses

## Install the 'inflection' package 
## Cite: https://cran.r-project.org/web/packages/inflection/readme/README.html 
#install.packages('inflection', dependencies = TRUE)
library(inflection)

## basic plotting:
par(mfrow=c(1,2))    # set plotting area into a 1-by-2 array

## Draw line of best fit for the miRDeep2_score
x <- 1:864
y <- miRNA_Genome_mapping$miRDeep2.score
plot(x, y, ylab = "miRDeep2_score", col = 'orchid2', xlab = "")

## Draw the line of best fit for the log2_miRDeep2_score
y_log2 <- log2(miRNA_Genome_mapping$miRDeep2.score)
### remove -Inf limit values
y_log2 <- y_log2[!is.infinite(y_log2)]
x_log2 <- c(1:length(y_log2))
plot(x_log2, y_log2, ylab = "log2_miRDeep2_score", col = 'skyblue1', xlab = "")

### calculate inflection point of log-transformed data
edeci_log2_miRDeep2_score <- edeci(x_log2, y_log2, 0, k=5)

###Add the lines demarcating the extreme estimates as well as the point of inflection
abline(v=c(538.5), col="black", lwd = 3)
abline(v = c(261, 816), lty = 2)

```


From a manual inspection of the 'consensus mature sequence' and the 'provisional id', which gives the locus of predicted miRNA mapping, we noticed that for a given 'consensus mature sequence', there could be multiple distinct mapping positions. This could either be on the same contig with a shift in the exact position mapped, or a different contig altogether. Below, we inspect the frequency of multi mapping, as well as whether there are patterns to such events e.g. Are there contig pairings i.e. any multi-mapping miRNA that maps to _contigA_, always maps to _contigB_? Or is it more random? Do certain pairs of contigs carry the majority of multi-mapping events? 

```{r, echo=FALSE}
# miRNA mapping statistics based on miRDeep2 analysis
## How many unique miRNA sequences?
print("No. of unique miRNA consensus mature sequences out of 864:")
length(unique(miRNA_Genome_mapping$consensus.mature.sequence))
    # 599 out of 864
    # 686/864 consensus.star.sequence
    # 749/864 consensus.precursor.sequence

## How many unique contigs did they map to?
### create a new column 'contig' that only has the contig name
miRNA_Genome_mapping$contig <- sub("^([A-Z0-9]+).*", "\\1", 
                                   miRNA_Genome_mapping$provisional.id)

print("No. of unique contigs miRNA sequences mapped to out of 20,337:")
length(unique(miRNA_Genome_mapping$contig))
    # 588 out of 20,337

## Count frequency of 'consensus.mature.sequence' mapping events to different contigs
### build table of 'consensus.mature.sequence' and 'contig'
miRNAconsensus_mature_seq_contig_list <-
  dplyr::select(miRNA_Genome_mapping, contig, consensus.mature.sequence)

### plot a bar graph illustrating miRNA mapping frequency to contigs
miRNAconsensus_mature_seq_contig_freq <- 
  miRNAconsensus_mature_seq_contig_list %>%
  group_by(consensus.mature.sequence) %>%
  summarise(contig = n())

par(mfrow=c(1,2))    # set plotting area into a 1-by-2 array
library(RColorBrewer)
#### bar plot
hist(miRNAconsensus_mature_seq_contig_freq$contig,
     main = "", xlab = "miRNA_mapping_events", xlim = range(0, 30), breaks = 30,
     ylim = range(0, 600))

#### table and pie-chart
miRNA_mapping_summary <- 
  as.data.frame(table(miRNAconsensus_mature_seq_contig_freq$contig))
miRNA_mapping_summary

miRNA_mapping_pct <- round(miRNA_mapping_summary$Freq/sum(miRNA_mapping_summary$Freq)*100)
pie(miRNA_mapping_summary$Freq, 
    labels = "",
    col = brewer.pal(8, "Accent"))
```

From the histogram plot above, many miRNA mapping events are not duplicate i.e. the miRNA sequence only maps to a single contig. Note that this analysis does not account for mapping events that appear on the same contig; these events would be considered 'single' mapping events. Nonetheless, it provided an entry point in exploring the mapping events; the pie-chart displays the same information.

```{r, echo=FALSE}
# Calculate contig matching frequency
## Nest the miRNAconsensus_mature_seq_contig_list so as to have all the contig_IDs embedded in miRNA seq_ID variable
nest_miRNAconsensus_mature_seq_contig_list <-
  nest(miRNAconsensus_mature_seq_contig_list, contig)

## Create a frequency list of the combinations of contig mapping events
contig_miRNA_combo_freq <- lapply(nest_miRNAconsensus_mature_seq_contig_list$data, 
                            function(x) length(unlist(x)))

### only look for pairs of combinations e.g. 
contig_miRNA_combo_list <- nest_miRNAconsensus_mature_seq_contig_list$data[contig_miRNA_combo_freq == 2]

### change data into dataframe (also includes a transposition to reorder objects)
contig_miRNA_combo_list_df <- as.data.frame(contig_miRNA_combo_list)
t_contig_miRNA_combo_list_df <- t(contig_miRNA_combo_list_df)
contig_miRNA_combo_list_final <- as.data.frame(t_contig_miRNA_combo_list_df)

### construct a dataframe that contains the counts of contig-combos
library(reshape2)
contig_miRNA_pair_counts <- melt(table(contig_miRNA_combo_list_final))
#View(contig_miRNA_pair_counts)
names(contig_miRNA_pair_counts) <- names(contig_miRNA_combo_list_final)
colnames(contig_miRNA_pair_counts)[ncol(contig_miRNA_pair_counts)] <- "count"
contig_miRNA_pair_counts

### filter out contig_combinations that never occur
filt_contig_miRNA_pair_counts <- contig_miRNA_pair_counts[contig_miRNA_pair_counts$count > 0, ]

# Create a density plot
ggplot(filt_contig_miRNA_pair_counts, aes(count)) + geom_density() + theme_classic()
```

From the density plot of contig pair frequency of double-mapping miRNA sequences to the genome, it appears that the majority of double-mapping events only occur once i.e. no specific contig pairs explain the majority of double mapping miRNA events. We interpret then that duplication of the genome assembly may not be so prominent. Further tests will be necessary prior to affirming any such conclusion.

##### _piRNA_ ######
